from flask import Flask, render_template, request, send_file, url_for, jsonify, send_from_directory, after_this_request, current_app
from werkzeug.utils import secure_filename
from datetime import datetime
import os
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Random import get_random_bytes
import zipfile


app = Flask(__name__)

# Create a directory to hold temporary files
temp_dir = os.path.join(os.getcwd(), 'temp')
os.makedirs(temp_dir, exist_ok=True)



def encrypt_file(file_content, password, filename):
    key = password.encode('utf-8')[:16]
    key = pad(key, AES.block_size)

    original_hash = calculate_hash(file_content)
    
    cipher = AES.new(key, AES.MODE_CBC)
    ct_bytes = cipher.encrypt(pad(file_content, AES.block_size))
    iv = cipher.iv
    
    # File name suffix
    encrypted_file_name = f"{os.path.splitext(filename)[0]}_encrypted{os.path.splitext(filename)[1]}"
    encrypted_file_path = os.path.join(temp_dir, encrypted_file_name)
    
    with open(encrypted_file_path, 'wb') as f:
        f.write(iv + ct_bytes + original_hash.encode())
    print(f"File written to {encrypted_file_path}")
    
    return encrypted_file_path, encrypted_file_name

def decrypt_file(encrypted_content, password, filename):
    key = password.encode('utf-8')[:16]
    key = pad(key, AES.block_size)

    stored_hash = encrypted_content[-64:].decode()
    encrypted_content = encrypted_content[:-64]
    
    iv = encrypted_content[:16]
    ct_bytes = encrypted_content[16:]
    
    cipher = AES.new(key, AES.MODE_CBC, iv)
    pt = unpad(cipher.decrypt(ct_bytes), AES.block_size)
    
    decrypted_hash = calculate_hash(pt)

    if decrypted_hash != stored_hash:
        raise ValueError("File integrity compromised.")
        
    # Desuffix
    decrypted_file_name = f"{os.path.splitext(filename)[0]}_decrypted{os.path.splitext(filename)[1]}"
    decrypted_file_path = os.path.join(temp_dir, decrypted_file_name)
    
    with open(decrypted_file_path, 'wb') as f:
        f.write(pt)
    
    return decrypted_file_path, decrypted_file_name

def calculate_hash(file_content):
    hasher = hashlib.sha256()
    hasher.update(file_content)
    return hasher.hexdigest()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/downloads/<path:filename>')
def download_file(filename):
    base_directory = temp_dir

    # Check whether files exist in the temp directory or any of its subdirectories
    full_path = os.path.join(base_directory, filename)
    if os.path.isfile(full_path):
        # Calculates the path of the file directory relative to base_directory
        directory = os.path.dirname(full_path)
        # Gets the base name of the file (without path)
        basename = os.path.basename(filename)
        return send_from_directory(directory, basename, as_attachment=True)
    else:
        return "File not found", 404

@app.route('/encrypt', methods=['POST'])
def handle_encrypt():
    file = request.files['file']
    password = request.form['password']
    secure_original_name = secure_filename(file.filename)
    
    encrypted_content, encrypted_file_name = encrypt_file(file.read(), password, secure_original_name)
    encrypted_file_path = os.path.join(temp_dir, encrypted_file_name)
    
    return jsonify({'download_url': url_for('download_file', filename=encrypted_file_name)})

    # return send_file(encrypted_file_path, as_attachment=True, download_name=encrypted_file_name)


@app.route('/decrypt', methods=['POST'])
def handle_decrypt():
    file = request.files['file']
    password = request.form['password']
    secure_original_name = secure_filename(file.filename)

    try:
        decrypted_content, decrypted_file_name = decrypt_file(file.read(), password, secure_original_name)
    except ValueError:
        response = jsonify({'error': 'Incorrect password, unable to decrypt.'})
        response.status_code = 400
        return response
    
    decrypted_file_path = os.path.join(temp_dir, decrypted_file_name)
    
    return jsonify({'download_url': url_for('download_file', filename=decrypted_file_name)})


    # return send_file(decrypted_file_path, as_attachment=True, download_name=decrypted_file_name)
............................................................................................................................................................

@app.route('/generate_key', methods=['GET'])
def generate_key():
    # Generate key pair
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    
    # Use the current time as the directory name to make sure it's different each time
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    key_dir = os.path.join('keys', timestamp)
    os.makedirs(key_dir, exist_ok=True)

    # Save the key with a unique file name
    private_keyN = timestamp + '_private.pem'
    public_keyN = timestamp + '_public.pem'
    private_key_file = os.path.join(key_dir, private_keyN)
    public_key_file = os.path.join(key_dir, public_keyN)
    
    # Writes the key to a file
    with open(private_key_file, 'wb') as priv_file:
        priv_file.write(private_key)
    with open(public_key_file, 'wb') as pub_file:
        pub_file.write(public_key)
    
    zip_filename = f"{timestamp}_keys.zip"
    zip_path = os.path.join(key_dir, zip_filename)
    with zipfile.ZipFile(zip_path, 'w') as zipf:
        zipf.write(private_key_file, private_keyN)
        zipf.write(public_key_file, public_keyN)

    return send_file(zip_path, as_attachment=True, download_name=zip_filename)
    # return jsonify({'download_url': url_for('download_file', filename=zip_filename)})






# Logout function
def logout(username):
    if username in users:
        users[username]["session_expiry"] = None
        return "Logged out successfully"
    return "User not found"

# Main execution
def module_one():
    print("=== User Authentication & Access Control ===")
    
    while True:
        print("\n1. Login\n2. Check Permission\n3. Logout\n4. Exit")
        choice = input("Select an option: ")
        
        if choice == "1":
            username = input("Username: ")
            password = getpass.getpass("Password: ")
            use_tfa = input("Enable Two-Factor Authentication? (y/n): ").lower() == 'y'
            success, message = login(username, password, use_tfa)
            print(message)
        
        elif choice == "2":
            username = input("Username: ")
            action = input("Action (read/write/delete): ")
            allowed, message = check_permission(username, action)
            print(message)
        
        elif choice == "3":
            username = input("Username: ")
            print(logout(username))
        
        elif choice == "4":
            print("Exiting...")
            break
        
        else:
            print("Invalid option")

# Run the module
if __name__ == "__main__":
    app.run(debug=True)
